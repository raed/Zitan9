package Utils;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Spliterators;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This class adds a buffer to a stream.
 * The items produced by a stream are buffered and can be reused.
 * The class also provides an iterator which allows one to access
 * the items produced by the stream only when they are needed.
 *
 */
public class BufferedStream<T> implements Iterator<T>,Iterable<T> {
    /** the buffer for the stream */
    private ArrayList<T> buffer = new ArrayList<>();
    /** the stream itself */
    private Stream<T> stream;
    /** a thread for accessing the stream */
    private Thread thread = null;
    /** an index for the buffer */
    private int index = 0;

    /** constructs a buffered stream
     *
     * @param stream the stream to be buffered.
     */
    public BufferedStream(Stream<T> stream) {
        this.stream = stream;}

    /** starts the thread.
     * It fetches the first item from the stream and then waits for a notify command
     *
     * @return true if the thread is started.
     */
    private boolean startThread() {
        if(thread == null) {
            thread = new Thread(()-> {
                synchronized(this) {
                    stream.anyMatch(item ->{
                        try{buffer.add(item);notify();wait(); return false;}
                        catch(Exception ex){return true;}});
                    stream = null;
                    notifyAll();}});
            thread.start();
            return true;}
        return false;}


    /** checks if there is a next item in the stream.
     * The item can either be taken from the buffer, or from the stream.
     *
     * @return true if there is a next item in the stream.
     */
    @Override
    public boolean hasNext() {
        if(index < buffer.size()) {return true;}
        if(stream == null) {return false;}
        if(startThread()){if(index < buffer.size()) {return true;}}
        synchronized(this) {
            notify();
            try{wait();}catch(Exception ex){}
            return index < buffer.size();}}

    /**
     * @return the next item
     */
    @Override
    public T next() {return buffer.get(index++);}

    public void close() {
        if(stream != null) {stream.close();thread.interrupt();}}



    /** returns a stream,
     * either the original stream, or the buffer's stream, or a new stream generated by the BufferedStream's iterator.
     * The new stream can be restarted by calling the reset-method.
     *
     * @param original if true then either the original stream, or the buffer's stream is returned (this cannot be restarted), otherwise a new restartable stream is generated
     * @return either the original stream, or a generated stream.
     */
    public Stream<T> stream(boolean original) {
        if(original) {return (stream == null) ? buffer.stream() : stream;}
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(this,0),false);}

    /** returns the original stream or the buffer's stream.
     * This stream cannot be reset
     *
     * @return the stream.
     */
    public Stream<T> stream() {
        return (stream == null) ? buffer.stream() : stream;}

    /** resets the stream and allows it to be restarted.
     * The restarted stream takes the items from the buffer.
     *
     */
    public void reset() {index = 0;}

    /**
     * @return true if al items are in the buffer.
     */
    public boolean allInBuffer() {return stream == null;}

    /** checks if the item is in the stream.
     * Comparison is done by the equals method.
     *
     * @param item the item to be checked
     * @return true if the item is in the stream.
     */
    public boolean contains(T item) {
        for(T object : this) {if(item.equals(object)) {return true;}}
        return false;}

    /** checks if the item is in the buffer
     *
     * @param item the item to be checked
     * @return true if the item is in the buffer.
     */
    public boolean containedInBuffer(T item) {
        return buffer.contains(item);}

    /** checks if the item is in the stream.
     * Comparison is done by the == method.
     *
     * @param item the item to be checked
     * @return true if the item is in the stream.
     */
    public boolean member(T item) {
        for(T object : this) {if(item == object) {return true;}}
        return false;}


    /** returns the current contents of the buffer as a string.
     *
     * @return the current contents of the buffer as a string,
     */
    @Override
    public String toString() {
        String s = Utilities.join(buffer,",",(item->item.toString()));
        if(!s.isEmpty()) {s += "\n";}
        return s + "Index: " + index;}

    /**
     * @return 'this' as iterator.
     */
    @Override
    public Iterator<T> iterator() {return this;}

    public static void main(String[] args) {
        ArrayList<Integer> l = new ArrayList<>();
        l.add(3); l.add(5); l.add(7);
        Stream st = l.stream();

        BufferedStream<Integer> bs = new BufferedStream<>(l.stream());
        System.out.println(bs.member(5));
        System.out.println(bs);
        while(bs.hasNext()) {
            int a = bs.next(); if (a == 5) {break;}
            System.out.println(a);}
        bs.reset();
        for(Integer i : bs) {
            System.out.println(i);}
        bs.reset();
        bs.stream(true).forEach(System.out::println);


    }


}

